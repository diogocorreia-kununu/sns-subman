#!/usr/bin/env python3

import boto3
import logging
import json
import argparse
import re
import os
import random

class DryRun:
    def create_queue(self, QueueName):
        logging.getLogger(SnsSubMan.APPNAME).info("[dry-run] AWS sqs.create_queue %s", QueueName)
        return { "url" : "http", "Attributes" : { "QueueArn" : "000", "Policy" : {} }}
    def create_topic(self, Name):
        logging.getLogger(SnsSubMan.APPNAME).info("[dry-run] AWS sns.create_topic %s", Name)
        return { "TopicArn" : "aws:000000000000:%s" % Name }
    def subscribe(self, TopicArn, Protocol, Endpoint):
        logging.getLogger(SnsSubMan.APPNAME).info(
            "[dry-run] AWS sns.subscribe(TopicArn=%s, Protocol=%s, Endpoint=%s)" % (
                TopicArn, Protocol, Endpoint
            )
        )

class SnsSubMan:
    VERSION = "0.0.5"
    APPNAME = "sns-subman"

    def __init__(self, config, endpoint_resolver, dry_run=False):
        self.logger = logging.getLogger(SnsSubMan.APPNAME)

        self.endpoint_resolver = endpoint_resolver
        self.dry_run = dry_run

        if self.dry_run:
            self.sns = DryRun()
        else:
            self.sns = boto3.client('sns', endpoint_url=self.endpoint_resolver['sns'])

        for topicName in config['subscriptions']:
            self.create_topic(NameParser.parse(topicName), config['subscriptions'][topicName]),

    def create_topic(self, topicName, subscriptions):
        topicName = NameParser.parse(topicName)

        self.logger.info("create topic %s" % topicName)
        self.topic = self.sns.create_topic(Name=topicName)

        for subscription in subscriptions:
            protocol, options = subscription.popitem()
            getattr(self, "subscribe_%s" % protocol)(options)

    def get_queue_policy(self, queue):
        try:
            return json.loads(queue.attributes['Policy'])
        except KeyError:
            return {
              "Version": "2012-10-17",
              "Id": "%s/SQSDefaultPolicy" % queue.attributes['QueueArn'],
              "Statement": []
            }

    def policy_has_permissions_for_topic(self, policy, topic):
        for statement in policy['Statement']:
            if statement['Condition']['ArnEquals']['aws:SourceArn'] == topic['TopicArn'] and statement['Effect'] == 'Allow':
                self.logger.info("policy permits access for %s. Yay!" % topic['TopicArn'])
                return True
        return False

    def subscribe_sqs(self, subscriptionDetails):

        if isinstance(subscriptionDetails, dict):
            queueName = NameParser.parse(subscriptionDetails["queueName"])
            filterPolicy = subscriptionDetails["filterPolicy"]
        elif isinstance(subscriptionDetails, str):
            queueName = subscriptionDetails
            filterPolicy = None
        else:
            self.logger.error('not expected data %s' % subscriptionDetails)
            return None

        self.logger.info("subscribe to sqs queue %s at %s" % (queueName, self.endpoint_resolver['sqs']))

        if self.dry_run:
            sqs = DryRun()
        else:
            sqs = boto3.client('sqs', endpoint_url=self.endpoint_resolver['sqs'])

        self.logger.info("create queue %s" % queueName)
        queue = sqs.create_queue(QueueName=queueName)
        self.logger.info("granting topic %s permission to access queue %s" % (self.topic['TopicArn'], queueName))

        if self.dry_run:
            endpoint="http://127.0.0.1"
        else:
            queue = boto3.resource('sqs', endpoint_url=self.endpoint_resolver['sqs']).get_queue_by_name(QueueName=queueName)
            endpoint=sqs.get_queue_attributes(QueueUrl=queue.url, AttributeNames=["QueueArn"])['Attributes']['QueueArn']

        policy = self.get_queue_policy(queue)

        if not self.policy_has_permissions_for_topic(policy, self.topic):
            self.logger.info("permissions are not set yet")
            policy['Statement'].append(
                    {
                        "Sid": "SidSubman%d" % (random.getrandbits(32)),
                        "Effect": "Allow",
                        "Principal": {
                            "AWS": "*"
                        },
                        "Action": "SQS:SendMessage",
                        "Resource": queue.attributes['QueueArn'],
                        "Condition": {
                            "ArnEquals": {
                                "aws:SourceArn": self.topic['TopicArn']
                                }
                            }
                        }
                    );

            sqs.set_queue_attributes(QueueUrl=queue.url, Attributes={'Policy': json.dumps(policy)})

        if filterPolicy:
            self.logger.info("subscribing with filter policy %s" % json.dumps(filterPolicy))
            self.sns.subscribe(
                TopicArn=self.topic['TopicArn'],
                Protocol='sqs',
                Endpoint=endpoint,
                Attributes={
                    'FilterPolicy': json.dumps(filterPolicy)
                }
            )
        else:
            self.logger.info("subscribing without filter policy")
            self.sns.subscribe(
                TopicArn=self.topic['TopicArn'],
                Protocol='sqs',
                Endpoint=endpoint
            )


    def subscribe_http(self, endpoint, protocol='http'):
        endpoint_url = self.endpoint_resolver[endpoint[0]] + endpoint[1]
        self.logger.info("subscribe to http endpoint %s at %s" % (endpoint, endpoint_url))

        self.sns.subscribe(
            TopicArn=self.topic['TopicArn'],
            Protocol=protocol,
            Endpoint=endpoint_url
        )

    def subscribe_https(self, endpoint):
        self.subscribe_http(endpoint, 'https')

class NoneEndpointResolver:
    def __getitem__(*args):
        return None

class tEndpointResolver:

    def __init__(self, config):
        self.endpoints = config

    def __getitem__(self, name):
        if not name in self.endpoints:
            return None
        return NameParser.parse(self.endpoints[name])


class NameParser:
    @staticmethod
    def parse(value):
        return NameParser.parse_env_vars(value)

    @staticmethod
    def parse_env_vars(value):
      output = re.search('%env\(([A-Z0-9_]+)\)%', value)

      if output is not None:
          envvar = output.group(1)
          if not envvar in os.environ:
            raise Exception("environment variable %s is not set" % envvar)
          value = value.replace('%%env(%s)%%' % envvar, os.environ[envvar])
          logging.getLogger(SnsSubMan.APPNAME).info("result: %s" % (value))

      return value

if __name__ == "__main__":
    logging.basicConfig()
    logging.getLogger(SnsSubMan.APPNAME).setLevel(logging.INFO)

    parser = argparse.ArgumentParser(description='Manage SNS subscriptions')
    parser.add_argument("config", help="The file that contains the topic and subscription informtion ", type=argparse.FileType('r'))
    parser.add_argument("--dry-run", help="Don't do anything, only show what would happen.", action='store_true')
    parser.add_argument('--version', action='version', version='%s %s' % (SnsSubMan.APPNAME, SnsSubMan.VERSION))

    args = parser.parse_args()

    config = json.loads("".join(args.config.readlines()))

    endpoint_resolver = NoneEndpointResolver()

    if 'endpoints' in config:
        endpoint_resolver = tEndpointResolver(config['endpoints'])

    snsSubMan = SnsSubMan(config, endpoint_resolver, dry_run=args.dry_run)

    logging.info("All queues and subscriptions created")
